"""Direct the client to resolve this field locally, either from the cache or local resolvers."""
directive @client(
  """
  When true, the client will never use the cache for this value. See
  https://www.apollographql.com/docs/react/essentials/local-state/#forcing-resolvers-with-clientalways-true
  """
  always: Boolean
) on FIELD | FRAGMENT_DEFINITION | INLINE_FRAGMENT

"""
Export this locally resolved field as a variable to be used in the remainder of this query. See
https://www.apollographql.com/docs/react/essentials/local-state/#using-client-fields-as-variables
"""
directive @export(
  """The variable name to export this field as."""
  as: String!
) on FIELD

"""
Specify a custom store key for this result. See
https://www.apollographql.com/docs/react/advanced/caching/#the-connection-directive
"""
directive @connection(
  """Specify the store key."""
  key: String!
  """An array of query argument names to include in the generated custom store key."""
  filter: [String!]
) on FIELD

type PriceData {
  price: Float
  change30d: Float
  population: Int
  lastSale: String
}

type CardRow {
  number: Int
  slug: String
  cardImage: String
  cardName: String
  setName: String
  setSlug: String
  year: Int
  psa10: PriceData
  psa9: PriceData
}

input FileInfoInput {
  name: String
  alternativeText: String
  caption: String
}

type UsersPermissionsMe {
  id: ID!
  username: String!
  email: String!
  confirmed: Boolean
  blocked: Boolean
  role: UsersPermissionsMeRole
}

type UsersPermissionsMeRole {
  id: ID!
  name: String!
  description: String
  type: String
}

input UsersPermissionsRegisterInput {
  username: String!
  email: String!
  password: String!
}

input UsersPermissionsLoginInput {
  identifier: String!
  password: String!
  provider: String = "local"
}

type UsersPermissionsLoginPayload {
  jwt: String
  user: UsersPermissionsMe!
}

type UserPermissionsPasswordPayload {
  ok: Boolean!
}

type CardSet {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String!
  slug: String!
  year: Long
  symbol: UploadFile
  logo: UploadFile
  expansion: Expansion
  cards_in_set: Int
  published_at: DateTime
  variants(sort: String, limit: Int, start: Int, where: JSON): [Variant!]!
  cards(sort: String, limit: Int, start: Int, where: JSON): [Card!]!
}

type CardSetConnection {
  values: [CardSet]
  groupBy: CardSetGroupBy
  aggregate: CardSetAggregator
}

type CardSetAggregator {
  count: Int
  totalCount: Int
  sum: CardSetAggregatorSum
  avg: CardSetAggregatorAvg
  min: CardSetAggregatorMin
  max: CardSetAggregatorMax
}

type CardSetAggregatorSum {
  cards_in_set: Float
}

type CardSetAggregatorAvg {
  cards_in_set: Float
}

type CardSetAggregatorMin {
  cards_in_set: Float
}

type CardSetAggregatorMax {
  cards_in_set: Float
}

type CardSetGroupBy {
  id: [CardSetConnectionId]
  created_at: [CardSetConnectionCreated_at]
  updated_at: [CardSetConnectionUpdated_at]
  name: [CardSetConnectionName]
  slug: [CardSetConnectionSlug]
  year: [CardSetConnectionYear]
  symbol: [CardSetConnectionSymbol]
  logo: [CardSetConnectionLogo]
  expansion: [CardSetConnectionExpansion]
  cards_in_set: [CardSetConnectionCards_in_set]
  published_at: [CardSetConnectionPublished_at]
}

type CardSetConnectionId {
  key: ID
  connection: CardSetConnection
}

type CardSetConnectionCreated_at {
  key: DateTime
  connection: CardSetConnection
}

type CardSetConnectionUpdated_at {
  key: DateTime
  connection: CardSetConnection
}

type CardSetConnectionName {
  key: String
  connection: CardSetConnection
}

type CardSetConnectionSlug {
  key: String
  connection: CardSetConnection
}

type CardSetConnectionYear {
  key: ID
  connection: CardSetConnection
}

type CardSetConnectionSymbol {
  key: ID
  connection: CardSetConnection
}

type CardSetConnectionLogo {
  key: ID
  connection: CardSetConnection
}

type CardSetConnectionExpansion {
  key: ID
  connection: CardSetConnection
}

type CardSetConnectionCards_in_set {
  key: Int
  connection: CardSetConnection
}

type CardSetConnectionPublished_at {
  key: DateTime
  connection: CardSetConnection
}

input CardSetInput {
  name: String!
  slug: String!
  year: Long
  symbol: ID
  logo: ID
  variants: [ID]
  cards: [ID]
  expansion: ID
  cards_in_set: Int
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editCardSetInput {
  name: String
  slug: String
  year: Long
  symbol: ID
  logo: ID
  variants: [ID]
  cards: [ID]
  expansion: ID
  cards_in_set: Int
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createCardSetInput {
  data: CardSetInput
}

type createCardSetPayload {
  cardSet: CardSet
}

input updateCardSetInput {
  where: InputID
  data: editCardSetInput
}

type updateCardSetPayload {
  cardSet: CardSet
}

input deleteCardSetInput {
  where: InputID
}

type deleteCardSetPayload {
  cardSet: CardSet
}

type Card {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String!
  slug: String
  number: Long!
  image: UploadFile
  card_set: CardSet
  variant: Variant
  published_at: DateTime
}

type CardConnection {
  values: [Card]
  groupBy: CardGroupBy
  aggregate: CardAggregator
}

type CardAggregator {
  count: Int
  totalCount: Int
}

type CardGroupBy {
  id: [CardConnectionId]
  created_at: [CardConnectionCreated_at]
  updated_at: [CardConnectionUpdated_at]
  name: [CardConnectionName]
  slug: [CardConnectionSlug]
  number: [CardConnectionNumber]
  image: [CardConnectionImage]
  card_set: [CardConnectionCard_set]
  variant: [CardConnectionVariant]
  published_at: [CardConnectionPublished_at]
}

type CardConnectionId {
  key: ID
  connection: CardConnection
}

type CardConnectionCreated_at {
  key: DateTime
  connection: CardConnection
}

type CardConnectionUpdated_at {
  key: DateTime
  connection: CardConnection
}

type CardConnectionName {
  key: String
  connection: CardConnection
}

type CardConnectionSlug {
  key: String
  connection: CardConnection
}

type CardConnectionNumber {
  key: ID
  connection: CardConnection
}

type CardConnectionImage {
  key: ID
  connection: CardConnection
}

type CardConnectionCard_set {
  key: ID
  connection: CardConnection
}

type CardConnectionVariant {
  key: ID
  connection: CardConnection
}

type CardConnectionPublished_at {
  key: DateTime
  connection: CardConnection
}

input CardInput {
  name: String!
  slug: String
  number: Long!
  image: ID
  card_set: ID
  variant: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editCardInput {
  name: String
  slug: String
  number: Long
  image: ID
  card_set: ID
  variant: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createCardInput {
  data: CardInput
}

type createCardPayload {
  card: Card
}

input updateCardInput {
  where: InputID
  data: editCardInput
}

type updateCardPayload {
  card: Card
}

input deleteCardInput {
  where: InputID
}

type deleteCardPayload {
  card: Card
}

type Expansion {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String!
  slug: String!
  published_at: DateTime
  card_sets(sort: String, limit: Int, start: Int, where: JSON): [CardSet!]!
}

type ExpansionConnection {
  values: [Expansion]
  groupBy: ExpansionGroupBy
  aggregate: ExpansionAggregator
}

type ExpansionAggregator {
  count: Int
  totalCount: Int
}

type ExpansionGroupBy {
  id: [ExpansionConnectionId]
  created_at: [ExpansionConnectionCreated_at]
  updated_at: [ExpansionConnectionUpdated_at]
  name: [ExpansionConnectionName]
  slug: [ExpansionConnectionSlug]
  published_at: [ExpansionConnectionPublished_at]
}

type ExpansionConnectionId {
  key: ID
  connection: ExpansionConnection
}

type ExpansionConnectionCreated_at {
  key: DateTime
  connection: ExpansionConnection
}

type ExpansionConnectionUpdated_at {
  key: DateTime
  connection: ExpansionConnection
}

type ExpansionConnectionName {
  key: String
  connection: ExpansionConnection
}

type ExpansionConnectionSlug {
  key: String
  connection: ExpansionConnection
}

type ExpansionConnectionPublished_at {
  key: DateTime
  connection: ExpansionConnection
}

input ExpansionInput {
  name: String!
  slug: String!
  card_sets: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editExpansionInput {
  name: String
  slug: String
  card_sets: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createExpansionInput {
  data: ExpansionInput
}

type createExpansionPayload {
  expansion: Expansion
}

input updateExpansionInput {
  where: InputID
  data: editExpansionInput
}

type updateExpansionPayload {
  expansion: Expansion
}

input deleteExpansionInput {
  where: InputID
}

type deleteExpansionPayload {
  expansion: Expansion
}

type Population {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  PSA10: Int!
  PSA9: Int!
  PSA8: Int!
  PSA7: Int!
  PSA6: Int!
  PSA5: Int!
  PSA4: Int!
  PSA3: Int!
  PSA2: Int!
  PSA1: Int!
  card: Card
  date_checked: DateTime!
  published_at: DateTime
}

type PopulationConnection {
  values: [Population]
  groupBy: PopulationGroupBy
  aggregate: PopulationAggregator
}

type PopulationAggregator {
  count: Int
  totalCount: Int
  sum: PopulationAggregatorSum
  avg: PopulationAggregatorAvg
  min: PopulationAggregatorMin
  max: PopulationAggregatorMax
}

type PopulationAggregatorSum {
  PSA10: Float
  PSA9: Float
  PSA8: Float
  PSA7: Float
  PSA6: Float
  PSA5: Float
  PSA4: Float
  PSA3: Float
  PSA2: Float
  PSA1: Float
}

type PopulationAggregatorAvg {
  PSA10: Float
  PSA9: Float
  PSA8: Float
  PSA7: Float
  PSA6: Float
  PSA5: Float
  PSA4: Float
  PSA3: Float
  PSA2: Float
  PSA1: Float
}

type PopulationAggregatorMin {
  PSA10: Float
  PSA9: Float
  PSA8: Float
  PSA7: Float
  PSA6: Float
  PSA5: Float
  PSA4: Float
  PSA3: Float
  PSA2: Float
  PSA1: Float
}

type PopulationAggregatorMax {
  PSA10: Float
  PSA9: Float
  PSA8: Float
  PSA7: Float
  PSA6: Float
  PSA5: Float
  PSA4: Float
  PSA3: Float
  PSA2: Float
  PSA1: Float
}

type PopulationGroupBy {
  id: [PopulationConnectionId]
  created_at: [PopulationConnectionCreated_at]
  updated_at: [PopulationConnectionUpdated_at]
  PSA10: [PopulationConnectionPSA10]
  PSA9: [PopulationConnectionPSA9]
  PSA8: [PopulationConnectionPSA8]
  PSA7: [PopulationConnectionPSA7]
  PSA6: [PopulationConnectionPSA6]
  PSA5: [PopulationConnectionPSA5]
  PSA4: [PopulationConnectionPSA4]
  PSA3: [PopulationConnectionPSA3]
  PSA2: [PopulationConnectionPSA2]
  PSA1: [PopulationConnectionPSA1]
  card: [PopulationConnectionCard]
  date_checked: [PopulationConnectionDate_checked]
  published_at: [PopulationConnectionPublished_at]
}

type PopulationConnectionId {
  key: ID
  connection: PopulationConnection
}

type PopulationConnectionCreated_at {
  key: DateTime
  connection: PopulationConnection
}

type PopulationConnectionUpdated_at {
  key: DateTime
  connection: PopulationConnection
}

type PopulationConnectionPSA10 {
  key: Int
  connection: PopulationConnection
}

type PopulationConnectionPSA9 {
  key: Int
  connection: PopulationConnection
}

type PopulationConnectionPSA8 {
  key: Int
  connection: PopulationConnection
}

type PopulationConnectionPSA7 {
  key: Int
  connection: PopulationConnection
}

type PopulationConnectionPSA6 {
  key: Int
  connection: PopulationConnection
}

type PopulationConnectionPSA5 {
  key: Int
  connection: PopulationConnection
}

type PopulationConnectionPSA4 {
  key: Int
  connection: PopulationConnection
}

type PopulationConnectionPSA3 {
  key: Int
  connection: PopulationConnection
}

type PopulationConnectionPSA2 {
  key: Int
  connection: PopulationConnection
}

type PopulationConnectionPSA1 {
  key: Int
  connection: PopulationConnection
}

type PopulationConnectionCard {
  key: ID
  connection: PopulationConnection
}

type PopulationConnectionDate_checked {
  key: DateTime
  connection: PopulationConnection
}

type PopulationConnectionPublished_at {
  key: DateTime
  connection: PopulationConnection
}

input PopulationInput {
  PSA10: Int
  PSA9: Int
  PSA8: Int
  PSA7: Int
  PSA6: Int
  PSA5: Int
  PSA4: Int
  PSA3: Int
  PSA2: Int
  PSA1: Int
  card: ID
  date_checked: DateTime!
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editPopulationInput {
  PSA10: Int
  PSA9: Int
  PSA8: Int
  PSA7: Int
  PSA6: Int
  PSA5: Int
  PSA4: Int
  PSA3: Int
  PSA2: Int
  PSA1: Int
  card: ID
  date_checked: DateTime
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createPopulationInput {
  data: PopulationInput
}

type createPopulationPayload {
  population: Population
}

input updatePopulationInput {
  where: InputID
  data: editPopulationInput
}

type updatePopulationPayload {
  population: Population
}

input deletePopulationInput {
  where: InputID
}

type deletePopulationPayload {
  population: Population
}

type Price {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  date: Date!
  price: Float
  auction_id: Long
  seller: String
  cert_number: Long
  sale_type: String
  card: Card
  grade: Int
  published_at: DateTime
}

type PriceConnection {
  values: [Price]
  groupBy: PriceGroupBy
  aggregate: PriceAggregator
}

type PriceAggregator {
  count: Int
  totalCount: Int
  sum: PriceAggregatorSum
  avg: PriceAggregatorAvg
  min: PriceAggregatorMin
  max: PriceAggregatorMax
}

type PriceAggregatorSum {
  price: Float
  grade: Float
}

type PriceAggregatorAvg {
  price: Float
  grade: Float
}

type PriceAggregatorMin {
  price: Float
  grade: Float
}

type PriceAggregatorMax {
  price: Float
  grade: Float
}

type PriceGroupBy {
  id: [PriceConnectionId]
  created_at: [PriceConnectionCreated_at]
  updated_at: [PriceConnectionUpdated_at]
  date: [PriceConnectionDate]
  price: [PriceConnectionPrice]
  auction_id: [PriceConnectionAuction_id]
  seller: [PriceConnectionSeller]
  cert_number: [PriceConnectionCert_number]
  sale_type: [PriceConnectionSale_type]
  card: [PriceConnectionCard]
  grade: [PriceConnectionGrade]
  published_at: [PriceConnectionPublished_at]
}

type PriceConnectionId {
  key: ID
  connection: PriceConnection
}

type PriceConnectionCreated_at {
  key: DateTime
  connection: PriceConnection
}

type PriceConnectionUpdated_at {
  key: DateTime
  connection: PriceConnection
}

type PriceConnectionDate {
  key: ID
  connection: PriceConnection
}

type PriceConnectionPrice {
  key: Float
  connection: PriceConnection
}

type PriceConnectionAuction_id {
  key: ID
  connection: PriceConnection
}

type PriceConnectionSeller {
  key: String
  connection: PriceConnection
}

type PriceConnectionCert_number {
  key: ID
  connection: PriceConnection
}

type PriceConnectionSale_type {
  key: String
  connection: PriceConnection
}

type PriceConnectionCard {
  key: ID
  connection: PriceConnection
}

type PriceConnectionGrade {
  key: Int
  connection: PriceConnection
}

type PriceConnectionPublished_at {
  key: DateTime
  connection: PriceConnection
}

input PriceInput {
  date: Date!
  price: Float
  auction_id: Long
  seller: String
  cert_number: Long
  sale_type: String
  card: ID
  grade: Int
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editPriceInput {
  date: Date
  price: Float
  auction_id: Long
  seller: String
  cert_number: Long
  sale_type: String
  card: ID
  grade: Int
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createPriceInput {
  data: PriceInput
}

type createPricePayload {
  price: Price
}

input updatePriceInput {
  where: InputID
  data: editPriceInput
}

type updatePricePayload {
  price: Price
}

input deletePriceInput {
  where: InputID
}

type deletePricePayload {
  price: Price
}

type Variant {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String!
  slug: String!
  published_at: DateTime
}

type VariantConnection {
  values: [Variant]
  groupBy: VariantGroupBy
  aggregate: VariantAggregator
}

type VariantAggregator {
  count: Int
  totalCount: Int
}

type VariantGroupBy {
  id: [VariantConnectionId]
  created_at: [VariantConnectionCreated_at]
  updated_at: [VariantConnectionUpdated_at]
  name: [VariantConnectionName]
  slug: [VariantConnectionSlug]
  published_at: [VariantConnectionPublished_at]
}

type VariantConnectionId {
  key: ID
  connection: VariantConnection
}

type VariantConnectionCreated_at {
  key: DateTime
  connection: VariantConnection
}

type VariantConnectionUpdated_at {
  key: DateTime
  connection: VariantConnection
}

type VariantConnectionName {
  key: String
  connection: VariantConnection
}

type VariantConnectionSlug {
  key: String
  connection: VariantConnection
}

type VariantConnectionPublished_at {
  key: DateTime
  connection: VariantConnection
}

input VariantInput {
  name: String!
  slug: String!
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editVariantInput {
  name: String
  slug: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createVariantInput {
  data: VariantInput
}

type createVariantPayload {
  variant: Variant
}

input updateVariantInput {
  where: InputID
  data: editVariantInput
}

type updateVariantPayload {
  variant: Variant
}

input deleteVariantInput {
  where: InputID
}

type deleteVariantPayload {
  variant: Variant
}

type UploadFile {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String!
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String!
  ext: String
  mime: String!
  size: Float!
  url: String!
  previewUrl: String
  provider: String!
  provider_metadata: JSON
  related(sort: String, limit: Int, start: Int, where: JSON): [Morph!]!
}

type UploadFileConnection {
  values: [UploadFile]
  groupBy: UploadFileGroupBy
  aggregate: UploadFileAggregator
}

type UploadFileAggregator {
  count: Int
  totalCount: Int
  sum: UploadFileAggregatorSum
  avg: UploadFileAggregatorAvg
  min: UploadFileAggregatorMin
  max: UploadFileAggregatorMax
}

type UploadFileAggregatorSum {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorAvg {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorMin {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorMax {
  width: Float
  height: Float
  size: Float
}

type UploadFileGroupBy {
  id: [UploadFileConnectionId]
  created_at: [UploadFileConnectionCreated_at]
  updated_at: [UploadFileConnectionUpdated_at]
  name: [UploadFileConnectionName]
  alternativeText: [UploadFileConnectionAlternativeText]
  caption: [UploadFileConnectionCaption]
  width: [UploadFileConnectionWidth]
  height: [UploadFileConnectionHeight]
  formats: [UploadFileConnectionFormats]
  hash: [UploadFileConnectionHash]
  ext: [UploadFileConnectionExt]
  mime: [UploadFileConnectionMime]
  size: [UploadFileConnectionSize]
  url: [UploadFileConnectionUrl]
  previewUrl: [UploadFileConnectionPreviewUrl]
  provider: [UploadFileConnectionProvider]
  provider_metadata: [UploadFileConnectionProvider_metadata]
}

type UploadFileConnectionId {
  key: ID
  connection: UploadFileConnection
}

type UploadFileConnectionCreated_at {
  key: DateTime
  connection: UploadFileConnection
}

type UploadFileConnectionUpdated_at {
  key: DateTime
  connection: UploadFileConnection
}

type UploadFileConnectionName {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionAlternativeText {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionCaption {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionWidth {
  key: Int
  connection: UploadFileConnection
}

type UploadFileConnectionHeight {
  key: Int
  connection: UploadFileConnection
}

type UploadFileConnectionFormats {
  key: JSON
  connection: UploadFileConnection
}

type UploadFileConnectionHash {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionExt {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionMime {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionSize {
  key: Float
  connection: UploadFileConnection
}

type UploadFileConnectionUrl {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionPreviewUrl {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionProvider {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionProvider_metadata {
  key: JSON
  connection: UploadFileConnection
}

input FileInput {
  name: String!
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String!
  ext: String
  mime: String!
  size: Float!
  url: String!
  previewUrl: String
  provider: String!
  provider_metadata: JSON
  related: [ID]
  created_by: ID
  updated_by: ID
}

input editFileInput {
  name: String
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String
  ext: String
  mime: String
  size: Float
  url: String
  previewUrl: String
  provider: String
  provider_metadata: JSON
  related: [ID]
  created_by: ID
  updated_by: ID
}

input deleteFileInput {
  where: InputID
}

type deleteFilePayload {
  file: UploadFile
}

type UsersPermissionsPermission {
  id: ID!
  type: String!
  controller: String!
  action: String!
  enabled: Boolean!
  policy: String
  role: UsersPermissionsRole
}

type UsersPermissionsRole {
  id: ID!
  name: String!
  description: String
  type: String
  permissions(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsPermission!]!
  users(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsUser!]!
}

type UsersPermissionsRoleConnection {
  values: [UsersPermissionsRole]
  groupBy: UsersPermissionsRoleGroupBy
  aggregate: UsersPermissionsRoleAggregator
}

type UsersPermissionsRoleAggregator {
  count: Int
  totalCount: Int
}

type UsersPermissionsRoleGroupBy {
  id: [UsersPermissionsRoleConnectionId]
  name: [UsersPermissionsRoleConnectionName]
  description: [UsersPermissionsRoleConnectionDescription]
  type: [UsersPermissionsRoleConnectionType]
}

type UsersPermissionsRoleConnectionId {
  key: ID
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionName {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionDescription {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionType {
  key: String
  connection: UsersPermissionsRoleConnection
}

input RoleInput {
  name: String!
  description: String
  type: String
  permissions: [ID]
  users: [ID]
  created_by: ID
  updated_by: ID
}

input editRoleInput {
  name: String
  description: String
  type: String
  permissions: [ID]
  users: [ID]
  created_by: ID
  updated_by: ID
}

input createRoleInput {
  data: RoleInput
}

type createRolePayload {
  role: UsersPermissionsRole
}

input updateRoleInput {
  where: InputID
  data: editRoleInput
}

type updateRolePayload {
  role: UsersPermissionsRole
}

input deleteRoleInput {
  where: InputID
}

type deleteRolePayload {
  role: UsersPermissionsRole
}

type UsersPermissionsUser {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  username: String!
  email: String!
  provider: String
  confirmed: Boolean
  blocked: Boolean
  role: UsersPermissionsRole
}

type UsersPermissionsUserConnection {
  values: [UsersPermissionsUser]
  groupBy: UsersPermissionsUserGroupBy
  aggregate: UsersPermissionsUserAggregator
}

type UsersPermissionsUserAggregator {
  count: Int
  totalCount: Int
}

type UsersPermissionsUserGroupBy {
  id: [UsersPermissionsUserConnectionId]
  created_at: [UsersPermissionsUserConnectionCreated_at]
  updated_at: [UsersPermissionsUserConnectionUpdated_at]
  username: [UsersPermissionsUserConnectionUsername]
  email: [UsersPermissionsUserConnectionEmail]
  provider: [UsersPermissionsUserConnectionProvider]
  confirmed: [UsersPermissionsUserConnectionConfirmed]
  blocked: [UsersPermissionsUserConnectionBlocked]
  role: [UsersPermissionsUserConnectionRole]
}

type UsersPermissionsUserConnectionId {
  key: ID
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionCreated_at {
  key: DateTime
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionUpdated_at {
  key: DateTime
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionUsername {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionEmail {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionProvider {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionConfirmed {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionBlocked {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionRole {
  key: ID
  connection: UsersPermissionsUserConnection
}

input UserInput {
  username: String!
  email: String!
  provider: String
  password: String
  resetPasswordToken: String
  confirmationToken: String
  confirmed: Boolean
  blocked: Boolean
  role: ID
  created_by: ID
  updated_by: ID
}

input editUserInput {
  username: String
  email: String
  provider: String
  password: String
  resetPasswordToken: String
  confirmationToken: String
  confirmed: Boolean
  blocked: Boolean
  role: ID
  created_by: ID
  updated_by: ID
}

input createUserInput {
  data: UserInput
}

type createUserPayload {
  user: UsersPermissionsUser
}

input updateUserInput {
  where: InputID
  data: editUserInput
}

type updateUserPayload {
  user: UsersPermissionsUser
}

input deleteUserInput {
  where: InputID
}

type deleteUserPayload {
  user: UsersPermissionsUser
}

union Morph = PriceData | CardRow | UsersPermissionsMe | UsersPermissionsMeRole | UsersPermissionsLoginPayload | UserPermissionsPasswordPayload | CardSet | CardSetConnection | CardSetAggregator | CardSetAggregatorSum | CardSetAggregatorAvg | CardSetAggregatorMin | CardSetAggregatorMax | CardSetGroupBy | CardSetConnectionId | CardSetConnectionCreated_at | CardSetConnectionUpdated_at | CardSetConnectionName | CardSetConnectionSlug | CardSetConnectionYear | CardSetConnectionSymbol | CardSetConnectionLogo | CardSetConnectionExpansion | CardSetConnectionCards_in_set | CardSetConnectionPublished_at | createCardSetPayload | updateCardSetPayload | deleteCardSetPayload | Card | CardConnection | CardAggregator | CardGroupBy | CardConnectionId | CardConnectionCreated_at | CardConnectionUpdated_at | CardConnectionName | CardConnectionSlug | CardConnectionNumber | CardConnectionImage | CardConnectionCard_set | CardConnectionVariant | CardConnectionPublished_at | createCardPayload | updateCardPayload | deleteCardPayload | Expansion | ExpansionConnection | ExpansionAggregator | ExpansionGroupBy | ExpansionConnectionId | ExpansionConnectionCreated_at | ExpansionConnectionUpdated_at | ExpansionConnectionName | ExpansionConnectionSlug | ExpansionConnectionPublished_at | createExpansionPayload | updateExpansionPayload | deleteExpansionPayload | Population | PopulationConnection | PopulationAggregator | PopulationAggregatorSum | PopulationAggregatorAvg | PopulationAggregatorMin | PopulationAggregatorMax | PopulationGroupBy | PopulationConnectionId | PopulationConnectionCreated_at | PopulationConnectionUpdated_at | PopulationConnectionPSA10 | PopulationConnectionPSA9 | PopulationConnectionPSA8 | PopulationConnectionPSA7 | PopulationConnectionPSA6 | PopulationConnectionPSA5 | PopulationConnectionPSA4 | PopulationConnectionPSA3 | PopulationConnectionPSA2 | PopulationConnectionPSA1 | PopulationConnectionCard | PopulationConnectionDate_checked | PopulationConnectionPublished_at | createPopulationPayload | updatePopulationPayload | deletePopulationPayload | Price | PriceConnection | PriceAggregator | PriceAggregatorSum | PriceAggregatorAvg | PriceAggregatorMin | PriceAggregatorMax | PriceGroupBy | PriceConnectionId | PriceConnectionCreated_at | PriceConnectionUpdated_at | PriceConnectionDate | PriceConnectionPrice | PriceConnectionAuction_id | PriceConnectionSeller | PriceConnectionCert_number | PriceConnectionSale_type | PriceConnectionCard | PriceConnectionGrade | PriceConnectionPublished_at | createPricePayload | updatePricePayload | deletePricePayload | Variant | VariantConnection | VariantAggregator | VariantGroupBy | VariantConnectionId | VariantConnectionCreated_at | VariantConnectionUpdated_at | VariantConnectionName | VariantConnectionSlug | VariantConnectionPublished_at | createVariantPayload | updateVariantPayload | deleteVariantPayload | UploadFile | UploadFileConnection | UploadFileAggregator | UploadFileAggregatorSum | UploadFileAggregatorAvg | UploadFileAggregatorMin | UploadFileAggregatorMax | UploadFileGroupBy | UploadFileConnectionId | UploadFileConnectionCreated_at | UploadFileConnectionUpdated_at | UploadFileConnectionName | UploadFileConnectionAlternativeText | UploadFileConnectionCaption | UploadFileConnectionWidth | UploadFileConnectionHeight | UploadFileConnectionFormats | UploadFileConnectionHash | UploadFileConnectionExt | UploadFileConnectionMime | UploadFileConnectionSize | UploadFileConnectionUrl | UploadFileConnectionPreviewUrl | UploadFileConnectionProvider | UploadFileConnectionProvider_metadata | deleteFilePayload | UsersPermissionsPermission | UsersPermissionsRole | UsersPermissionsRoleConnection | UsersPermissionsRoleAggregator | UsersPermissionsRoleGroupBy | UsersPermissionsRoleConnectionId | UsersPermissionsRoleConnectionName | UsersPermissionsRoleConnectionDescription | UsersPermissionsRoleConnectionType | createRolePayload | updateRolePayload | deleteRolePayload | UsersPermissionsUser | UsersPermissionsUserConnection | UsersPermissionsUserAggregator | UsersPermissionsUserGroupBy | UsersPermissionsUserConnectionId | UsersPermissionsUserConnectionCreated_at | UsersPermissionsUserConnectionUpdated_at | UsersPermissionsUserConnectionUsername | UsersPermissionsUserConnectionEmail | UsersPermissionsUserConnectionProvider | UsersPermissionsUserConnectionConfirmed | UsersPermissionsUserConnectionBlocked | UsersPermissionsUserConnectionRole | createUserPayload | updateUserPayload | deleteUserPayload

input InputID {
  id: ID!
}

enum PublicationState {
  LIVE
  PREVIEW
}

type AdminUser {
  id: ID!
  username: String
  firstname: String!
  lastname: String!
}

type Query {
  cardSet(id: ID!, publicationState: PublicationState): CardSet
  cardSets(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [CardSet!]!
  cardSetsConnection(sort: String, limit: Int, start: Int, where: JSON): CardSetConnection
  card(id: ID!, publicationState: PublicationState): Card
  cards(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Card!]!
  cardsConnection(sort: String, limit: Int, start: Int, where: JSON): CardConnection
  expansion(id: ID!, publicationState: PublicationState): Expansion
  expansions(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Expansion!]!
  expansionsConnection(sort: String, limit: Int, start: Int, where: JSON): ExpansionConnection
  population(id: ID!, publicationState: PublicationState): Population
  populations(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Population!]!
  populationsConnection(sort: String, limit: Int, start: Int, where: JSON): PopulationConnection
  price(id: ID!, publicationState: PublicationState): Price
  prices(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Price!]!
  pricesConnection(sort: String, limit: Int, start: Int, where: JSON): PriceConnection
  variant(id: ID!, publicationState: PublicationState): Variant
  variants(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Variant!]!
  variantsConnection(sort: String, limit: Int, start: Int, where: JSON): VariantConnection
  files(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UploadFile!]!
  filesConnection(sort: String, limit: Int, start: Int, where: JSON): UploadFileConnection
  role(id: ID!, publicationState: PublicationState): UsersPermissionsRole
  """Retrieve all the existing roles. You can't apply filters on this query."""
  roles(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UsersPermissionsRole!]!
  rolesConnection(sort: String, limit: Int, start: Int, where: JSON): UsersPermissionsRoleConnection
  user(id: ID!, publicationState: PublicationState): UsersPermissionsUser
  users(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UsersPermissionsUser!]!
  usersConnection(sort: String, limit: Int, start: Int, where: JSON): UsersPermissionsUserConnection
  getCardsTable(setSlug: String!): [CardRow!]!
  me: UsersPermissionsMe
}

type Mutation {
  createCardSet(input: createCardSetInput): createCardSetPayload
  updateCardSet(input: updateCardSetInput): updateCardSetPayload
  deleteCardSet(input: deleteCardSetInput): deleteCardSetPayload
  createCard(input: createCardInput): createCardPayload
  updateCard(input: updateCardInput): updateCardPayload
  deleteCard(input: deleteCardInput): deleteCardPayload
  createExpansion(input: createExpansionInput): createExpansionPayload
  updateExpansion(input: updateExpansionInput): updateExpansionPayload
  deleteExpansion(input: deleteExpansionInput): deleteExpansionPayload
  createPopulation(input: createPopulationInput): createPopulationPayload
  updatePopulation(input: updatePopulationInput): updatePopulationPayload
  deletePopulation(input: deletePopulationInput): deletePopulationPayload
  createPrice(input: createPriceInput): createPricePayload
  updatePrice(input: updatePriceInput): updatePricePayload
  deletePrice(input: deletePriceInput): deletePricePayload
  createVariant(input: createVariantInput): createVariantPayload
  updateVariant(input: updateVariantInput): updateVariantPayload
  deleteVariant(input: deleteVariantInput): deleteVariantPayload
  """Delete one file"""
  deleteFile(input: deleteFileInput): deleteFilePayload
  """Create a new role"""
  createRole(input: createRoleInput): createRolePayload
  """Update an existing role"""
  updateRole(input: updateRoleInput): updateRolePayload
  """Delete an existing role"""
  deleteRole(input: deleteRoleInput): deleteRolePayload
  """Create a new user"""
  createUser(input: createUserInput): createUserPayload
  """Update an existing user"""
  updateUser(input: updateUserInput): updateUserPayload
  """Delete an existing user"""
  deleteUser(input: deleteUserInput): deleteUserPayload
  upload(refId: ID, ref: String, field: String, source: String, file: Upload!): UploadFile!
  multipleUpload(refId: ID, ref: String, field: String, source: String, files: [Upload]!): [UploadFile]!
  updateFileInfo(id: ID!, info: FileInfoInput!): UploadFile!
  login(input: UsersPermissionsLoginInput!): UsersPermissionsLoginPayload!
  register(input: UsersPermissionsRegisterInput!): UsersPermissionsLoginPayload!
  forgotPassword(email: String!): UserPermissionsPasswordPayload
  resetPassword(password: String!, passwordConfirmation: String!, code: String!): UsersPermissionsLoginPayload
  emailConfirmation(confirmation: String!): UsersPermissionsLoginPayload
}

"""The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."""
scalar JSON

"""A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."""
scalar DateTime

"""A time string with format: HH:mm:ss.SSS"""
scalar Time

"""A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."""
scalar Date

"""The `Long` scalar type represents 52-bit integers"""
scalar Long

"""The `Upload` scalar type represents a file upload."""
scalar Upload

enum CacheControlScope {
  PUBLIC
  PRIVATE
}
